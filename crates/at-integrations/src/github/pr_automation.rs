use at_core::types::Task;
use serde::{Deserialize, Serialize};

use crate::types::GitHubPullRequest;

use super::client::{GitHubClient, Result};
use super::pull_requests;

/// Status of a pull request including checks, reviews, and mergeability.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrStatus {
    pub mergeable: Option<bool>,
    pub checks_passing: bool,
    pub review_count: u32,
    pub approved: bool,
}

/// Automates PR creation when tasks reach completion.
pub struct PrAutomation {
    client: GitHubClient,
}

impl PrAutomation {
    /// Create a new PR automation instance with the given GitHub client.
    pub fn new(client: GitHubClient) -> Self {
        Self { client }
    }

    /// Create a PR from a completed task's worktree branch.
    ///
    /// The task must have a `git_branch` set, which is used as the head branch.
    /// The `base` parameter specifies the target branch (e.g. `"main"`).
    pub async fn create_pr_for_task(&self, task: &Task, base: &str) -> Result<GitHubPullRequest> {
        let head = task.git_branch.as_deref().unwrap_or("main");

        let body = self.generate_pr_body(task);

        let pr =
            pull_requests::create_pull_request(&self.client, &task.title, Some(&body), head, base)
                .await?;

        Ok(pr)
    }

    /// Generate a PR description from task metadata and logs.
    pub fn generate_pr_body(&self, task: &Task) -> String {
        let mut body = String::new();

        // Title and description
        body.push_str(&format!("## {}\n\n", task.title));

        if let Some(desc) = &task.description {
            body.push_str(&format!("{}\n\n", desc));
        }

        // Phase completion summary
        body.push_str("### Phase Summary\n\n");
        body.push_str(&format!("- **Current Phase**: {:?}\n", task.phase));
        body.push_str(&format!("- **Progress**: {}%\n", task.progress_percent));
        body.push_str(&format!("- **Category**: {:?}\n", task.category));
        body.push_str(&format!("- **Priority**: {:?}\n", task.priority));
        body.push_str(&format!("- **Complexity**: {:?}\n", task.complexity));

        if let Some(started) = &task.started_at {
            body.push_str(&format!(
                "- **Started**: {}\n",
                started.format("%Y-%m-%d %H:%M UTC")
            ));
        }
        if let Some(completed) = &task.completed_at {
            body.push_str(&format!(
                "- **Completed**: {}\n",
                completed.format("%Y-%m-%d %H:%M UTC")
            ));
        }

        // Worktree info
        if let Some(worktree) = &task.worktree_path {
            body.push_str(&format!("\n### Worktree\n\n`{}`\n", worktree));
        }

        // Task logs summary (last 10 entries)
        if !task.logs.is_empty() {
            body.push_str("\n### Activity Log\n\n");
            let log_slice = if task.logs.len() > 10 {
                &task.logs[task.logs.len() - 10..]
            } else {
                &task.logs
            };

            for entry in log_slice {
                body.push_str(&format!(
                    "- `[{:?}]` {}: {}\n",
                    entry.phase,
                    entry.log_type_label(),
                    entry.message
                ));
            }
        }

        // Subtask summary
        if !task.subtasks.is_empty() {
            body.push_str("\n### Subtasks\n\n");
            for subtask in &task.subtasks {
                let check = match subtask.status {
                    at_core::types::SubtaskStatus::Complete => "[x]",
                    at_core::types::SubtaskStatus::Failed => "[!]",
                    at_core::types::SubtaskStatus::Skipped => "[-]",
                    _ => "[ ]",
                };
                body.push_str(&format!("- {} {}\n", check, subtask.title));
            }
        }

        body.push_str("\n---\n*Auto-generated by auto-tundra*\n");

        body
    }

    /// Check PR status (mergeable, checks passing, reviews).
    pub async fn check_pr_status(&self, pr_number: u64) -> Result<PrStatus> {
        let pr = pull_requests::get_pull_request(&self.client, pr_number).await?;

        Ok(PrStatus {
            mergeable: pr.mergeable,
            checks_passing: pr.mergeable.unwrap_or(false),
            review_count: pr.reviewers.len() as u32,
            approved: !pr.reviewers.is_empty() && pr.mergeable.unwrap_or(false),
        })
    }
}

/// Extension trait to get a label from TaskLogType without requiring Display.
trait TaskLogEntryExt {
    fn log_type_label(&self) -> &'static str;
}

impl TaskLogEntryExt for at_core::types::TaskLogEntry {
    fn log_type_label(&self) -> &'static str {
        match self.log_type {
            at_core::types::TaskLogType::Text => "text",
            at_core::types::TaskLogType::PhaseStart => "phase_start",
            at_core::types::TaskLogType::PhaseEnd => "phase_end",
            at_core::types::TaskLogType::ToolStart => "tool_start",
            at_core::types::TaskLogType::ToolEnd => "tool_end",
            at_core::types::TaskLogType::Error => "error",
            at_core::types::TaskLogType::Success => "success",
            at_core::types::TaskLogType::Info => "info",
        }
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use at_core::types::{
        Subtask, SubtaskStatus, Task, TaskCategory, TaskComplexity, TaskLogType, TaskPhase,
        TaskPriority,
    };
    use uuid::Uuid;

    /// Helper to create a task for testing.
    fn make_test_task(title: &str, phase: TaskPhase) -> Task {
        let mut task = Task::new(
            title.to_string(),
            Uuid::new_v4(),
            TaskCategory::Feature,
            TaskPriority::Medium,
            TaskComplexity::Medium,
        );
        task.set_phase(phase);
        task.description = Some("A test task description.".to_string());
        task.git_branch = Some("feature/test-branch".to_string());
        task.worktree_path = Some("/tmp/worktree/test".to_string());
        task
    }

    #[test]
    fn test_generate_pr_body_includes_title() {
        let task = make_test_task("Add user auth", TaskPhase::Complete);
        let body = generate_pr_body_for_task(&task);
        assert!(body.contains("## Add user auth"));
        assert!(body.contains("A test task description."));
    }

    #[test]
    fn test_generate_pr_body_includes_phase_summary() {
        let task = make_test_task("Fix login bug", TaskPhase::Complete);
        let body = generate_pr_body_for_task(&task);

        assert!(body.contains("### Phase Summary"));
        assert!(body.contains("Complete"));
        assert!(body.contains("100%"));
        assert!(body.contains("Feature"));
    }

    #[test]
    fn test_generate_pr_body_includes_worktree() {
        let task = make_test_task("Refactor DB layer", TaskPhase::Coding);
        let body = generate_pr_body_for_task(&task);

        assert!(body.contains("### Worktree"));
        assert!(body.contains("/tmp/worktree/test"));
    }

    #[test]
    fn test_generate_pr_body_includes_logs() {
        let mut task = make_test_task("Add tests", TaskPhase::Qa);
        task.log(TaskLogType::PhaseStart, "Starting QA phase");
        task.log(TaskLogType::Info, "Running test suite");
        task.log(TaskLogType::Success, "All tests passed");

        let body = generate_pr_body_for_task(&task);

        assert!(body.contains("### Activity Log"));
        assert!(body.contains("Starting QA phase"));
        assert!(body.contains("All tests passed"));
    }

    #[test]
    fn test_generate_pr_body_includes_subtasks() {
        let mut task = make_test_task("Multi-step feature", TaskPhase::Complete);
        task.subtasks = vec![
            Subtask {
                id: Uuid::new_v4(),
                title: "Create schema".to_string(),
                status: SubtaskStatus::Complete,
                agent_id: None,
                depends_on: vec![],
            },
            Subtask {
                id: Uuid::new_v4(),
                title: "Write migration".to_string(),
                status: SubtaskStatus::InProgress,
                agent_id: None,
                depends_on: vec![],
            },
            Subtask {
                id: Uuid::new_v4(),
                title: "Update API".to_string(),
                status: SubtaskStatus::Failed,
                agent_id: None,
                depends_on: vec![],
            },
        ];

        let body = generate_pr_body_for_task(&task);

        assert!(body.contains("### Subtasks"));
        assert!(body.contains("[x] Create schema"));
        assert!(body.contains("[ ] Write migration"));
        assert!(body.contains("[!] Update API"));
    }

    #[test]
    fn test_pr_status_struct() {
        let status = PrStatus {
            mergeable: Some(true),
            checks_passing: true,
            review_count: 2,
            approved: true,
        };

        assert_eq!(status.mergeable, Some(true));
        assert!(status.checks_passing);
        assert_eq!(status.review_count, 2);
        assert!(status.approved);
    }

    /// Standalone body generation to avoid needing a GitHubClient in tests.
    fn generate_pr_body_for_task(task: &Task) -> String {
        let mut body = String::new();

        body.push_str(&format!("## {}\n\n", task.title));

        if let Some(desc) = &task.description {
            body.push_str(&format!("{}\n\n", desc));
        }

        body.push_str("### Phase Summary\n\n");
        body.push_str(&format!("- **Current Phase**: {:?}\n", task.phase));
        body.push_str(&format!("- **Progress**: {}%\n", task.progress_percent));
        body.push_str(&format!("- **Category**: {:?}\n", task.category));
        body.push_str(&format!("- **Priority**: {:?}\n", task.priority));
        body.push_str(&format!("- **Complexity**: {:?}\n", task.complexity));

        if let Some(started) = &task.started_at {
            body.push_str(&format!(
                "- **Started**: {}\n",
                started.format("%Y-%m-%d %H:%M UTC")
            ));
        }
        if let Some(completed) = &task.completed_at {
            body.push_str(&format!(
                "- **Completed**: {}\n",
                completed.format("%Y-%m-%d %H:%M UTC")
            ));
        }

        if let Some(worktree) = &task.worktree_path {
            body.push_str(&format!("\n### Worktree\n\n`{}`\n", worktree));
        }

        if !task.logs.is_empty() {
            body.push_str("\n### Activity Log\n\n");
            let log_slice = if task.logs.len() > 10 {
                &task.logs[task.logs.len() - 10..]
            } else {
                &task.logs
            };

            for entry in log_slice {
                let label = match entry.log_type {
                    TaskLogType::Text => "text",
                    TaskLogType::PhaseStart => "phase_start",
                    TaskLogType::PhaseEnd => "phase_end",
                    TaskLogType::ToolStart => "tool_start",
                    TaskLogType::ToolEnd => "tool_end",
                    TaskLogType::Error => "error",
                    TaskLogType::Success => "success",
                    TaskLogType::Info => "info",
                };
                body.push_str(&format!(
                    "- `[{:?}]` {}: {}\n",
                    entry.phase, label, entry.message
                ));
            }
        }

        if !task.subtasks.is_empty() {
            body.push_str("\n### Subtasks\n\n");
            for subtask in &task.subtasks {
                let check = match subtask.status {
                    SubtaskStatus::Complete => "[x]",
                    SubtaskStatus::Failed => "[!]",
                    SubtaskStatus::Skipped => "[-]",
                    _ => "[ ]",
                };
                body.push_str(&format!("- {} {}\n", check, subtask.title));
            }
        }

        body.push_str("\n---\n*Auto-generated by auto-tundra*\n");

        body
    }
}
